function [Problem,Guess,x,F,inform,xmul,Fmul,xstate,Fstate,output]=traj_opt_multipleshoot(nNodesF1,nNodesS,nNodesF2,pogo)
    nNodes=nNodesF1+nNodesS+nNodesF2;
    %% Get initial guess
    Guess=getGuess(nNodesF1,nNodesS,nNodesF2,pogo);
    Problem.x0=Guess;
    %% Bounds
    
    %time bounds
    LB_t = [0.01 0.01 0.01];
    UB_t = [3 2 3];
    
    %stance lower bounds
    LBS_q = [pogo.parameters.lmin];
    LBS_dq = -50;
    LBS_u = -4000;
    
    %stance upper bounds
    UBS_q = [pogo.parameters.lmax];
    UBS_dq = 50;
    UBS_u = 4000;
    
    %flight lower bounds
    LBF_q = [pogo.parameters.lmin pogo.parameters.lmin];
    LBF_dq = [-50 -50];
    LBF_u = -4000;
    
    %flight upper bounds
    UBF_q = [2*pogo.parameters.init_q(1) pogo.parameters.lmax];
    UBF_dq = [50 50];
    UBF_u = 4000;
    %% remap bounds for the problem (must match the guess order)
    Problem.lb=[LB_t,repmat([LBF_q,LBF_dq,LBF_u],1,nNodesF1),repmat([LBS_q,LBS_dq,LBS_u],1,nNodesS),repmat([LBF_q,LBF_dq,LBF_u],1,nNodesF2)];
    Problem.ub=[UB_t,repmat([UBF_q,UBF_dq,UBF_u],1,nNodesF1),repmat([UBS_q,UBS_dq,UBS_u],1,nNodesS),repmat([UBF_q,UBF_dq,UBF_u],1,nNodesF2)];
    %%
    %no linear constraints, all handled in the nonlincon function
    Problem.Aineq = [];%tempA;%Aineq x<=bineq
    Problem.bineq = [];%tempb;
    
    Problem.Aeq = [];%Aeq x=beq
    Problem.beq = [];  
    %% user-defined functions
    %set the initial conditions
    q0=pogo.parameters.init_q;
    dq0=pogo.parameters.init_dq;
    

    
    global auxdata
    
    auxdata.nNodesF1=nNodesF1;
    auxdata.nNodesS=nNodesS;
    auxdata.nNodesF2=nNodesF2;
    auxdata.q_0=q0;
    auxdata.dq_0=dq0;
    auxdata.lmin=pogo.parameters.lmin;
    auxdata.lmax=pogo.parameters.lmax;
    auxdata.pogo=pogo;
    
    Problem.obj=@objective;
    Problem.con=@constraint;
    Problem.user=@userfunction;
    %% SOLVE PROBLEM
    snscreen on;
    snprint('traj_opt_multipleshoot.out');  % By default, screen output is off;
    snseti ('Verify Level', 0);%set to 3 to check the gradients
    snseti ('Major Iteration limit', 250);
    
    [F,~]=userfunction(Problem.x0);%run the function once with dummy data to determine sizes
    [c,ceq,~,~]=constraint(Problem.x0);%run the function once with dummy data to determine sizes
    
    n  = size(Problem.x0);
    nle = length(ceq);
    nli = length(c);
    nCon = size(F);
    
    x       =Problem.x0';
    xlow    =Problem.lb';
    xupp    =Problem.ub';
    xmul    =zeros(n); %contains the initial multipliers for x.
    xstate  =zeros(n); %are the states of the variables x.
    Flow    =[ -inf; -inf*ones(nli,1); zeros(nle,1) ];%are the upper and lower bounds on F.%%% the limits for the eq and ineq constraints 
    Fupp    =[  inf; zeros(nli,1); zeros(nle,1) ];
    Fmul    =zeros(nCon);%zeros(length(F),1);%contains the initial multipliers for F.
    Fstate  =zeros(nCon);%zeros(length(F),1);%are the states of the constraints F.
    A       =[];
    iAfun   =[];
    jAvar   =[];
    
    gx.f = x;
    gx.dx = ones(168,1);
    obj = pogo_objective_ADiGatorGrd(gx,auxdata);
    
    [con, coneq] = pogo_nonlcon_ADiGatorGrd(gx,auxdata);
    
    iGcon = con.dx_location(:,1)+1;%add one for the cost function
    iGceq = coneq.dx_location(:,1)+max(iGcon);%use max and not length as its a sparce matrix
    
    iGfun = [ones(size(obj.dx_location));iGcon;                 iGceq];
    jGvar = [obj.dx_location;            con.dx_location(:,2);  coneq.dx_location(:,2)];%dx_location is part of the structure generated by ADIgator
    
    userfun=Problem.user;
    
    [x,F,inform,xmul,Fmul,xstate,Fstate,output] = snopt ( x, xlow, xupp, xmul, xstate,...
                                                  Flow, Fupp, Fmul, Fstate, userfun,...
                                                  A, iAfun, jAvar, iGfun, jGvar );
    snprint off;
    snend;
end